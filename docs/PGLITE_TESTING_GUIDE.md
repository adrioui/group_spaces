# PGlite Testing Integration Guide (Next.js + TypeScript + Drizzle)

This guide explains how to integrate PGlite for fast, isolated testing with Vitest and Playwright in this repository. It is intended to be implemented by another engineer (Claude Code) as a series of small, reviewable changes. No production behavior changes are required; PGlite is test-only and opt-in via environment variables.

Goals
- Enable in-memory, Postgres-compatible testing that is fast and hermetic.
- Keep dev/prod on real Postgres. Use PGlite only for unit/integration/E2E tests.
- Reuse Drizzle migrations and seeds so schema and data match production intent.
- Support parallel test execution with predictable isolation.

Repo context (important when wiring)
- DB client: Drizzle ORM with `postgres-js` in `src/db/index.ts` (throws if `DATABASE_URL` is missing at import time).
- Schema: `src/db/schema.ts` with Drizzle pg-core.
- Seeds: `src/db/seeds/*.ts` (currently import the `@/db` singleton directly).
- Migrations: SQL outputs under `drizzle/` (generated by `drizzle-kit`).
- Tests: Vitest configured in `vitest.config.ts`; Playwright configured in `playwright.config.ts` with `src/tests/e2e/global-setup.ts` pointing to local Postgres.

When to use PGlite vs Postgres
- PGlite: default for local fast runs and CI where speed/isolation are key.
- Postgres: fallback for features not yet supported by PGlite; keep for load/perf tests.

High-level plan
1) Add PGlite as a dev dependency and create a test-only PGlite DB setup.
2) Provide a Drizzle client bound to PGlite for tests (without changing production code paths).
3) Implement a migration runner that applies SQL from `drizzle/` to PGlite.
4) Implement minimal, deterministic seeding for tests (reuse existing seed data when possible).
5) Wire Vitest global setup to boot PGlite, migrate, and seed.
6) Wire Playwright global setup to run the app against PGlite in E2E.
7) Add npm scripts and docs; optionally add a CI matrix job.

Environment variables (add to `.env.example`; do not commit secrets)
- `TEST_DB=pglite|postgres` (default: `postgres`). Controls test DB backend.
- `PGLITE_PERSIST=memory|filesystem` (default: `memory`).
- `PGLITE_DATA_DIR=.pglite` (used only when `PGLITE_PERSIST=filesystem`).
- `PGLITE_VERBOSE=0|1` (debug logging in setup scripts).
- `PGLITE_ISOLATION=run|worker` (Vitest isolation level; default: `run`).

Proposed file layout (new files to add)
- `docs/PGLITE_TESTING_GUIDE.md` (this guide)
- `docs/pglite/IMPLEMENTATION_CHECKLIST.md` (task breakdown and acceptance criteria)
- `docs/pglite/TEMPLATES.md` (copy‑ready code snippets)
- `src/tests/pglite/setup-global.ts` (Vitest global setup; starts PGlite, migrates, seeds)
- `src/tests/pglite/test-db.ts` (exports a Drizzle instance bound to PGlite)
- `src/tests/pglite/utils.ts` (migration + seed helpers)
- `playwright.pglite.global-setup.ts` (Playwright PGlite global setup)

Implementation strategy (detailed)

1) Install and pin dependencies
- `npm i -D pglite`
- Ensure current `drizzle-orm` supports the `drizzle-orm/pglite` driver; our repo uses `^0.44.5`, which supports PGlite.

2) Test-only DB factory (no production code changes required)
- Create `src/tests/pglite/test-db.ts` that:
  - Creates a PGlite instance (in-memory by default; filesystem when configured).
  - Wraps it with `drizzle` from `drizzle-orm/pglite` and passes `schema`.
  - Exports the Drizzle `db` and optionally the raw PGlite connection for admin tasks.
- Tests that need DB access import `db` from `src/tests/pglite/test-db` instead of `@/db` when `TEST_DB=pglite`.
- Alternative (optional, for E2E): add a strictly env-gated conditional in `src/db/index.ts` so API routes use PGlite when `TEST_DB=pglite`. Keep the default path unchanged for dev/prod.

3) Migration runner for PGlite
- Implement helpers to:
  - Read SQL files from `drizzle/` in lexicographical order.
  - Maintain a `_migrations` table inside PGlite to track applied migrations.
  - Apply each SQL file once; skip if already applied.
  - Log progress clearly when `PGLITE_VERBOSE=1`.

4) Seeding strategy
- Prefer refactoring existing seed scripts to accept a `db` argument and export seed functions; then call them from a test-only `seedAll(db)` helper.
- If refactor is out of scope initially, implement a small test-only seeder that inserts only the rows needed by current tests.
- Keep seeds minimal and deterministic for speed.

5) Vitest integration
- Add `src/tests/pglite/setup-global.ts`:
  - Set `TEST_DB=pglite` in `process.env`.
  - Start a PGlite instance (once per run, or per worker if `PGLITE_ISOLATION=worker`).
  - Run migrations and seed data.
  - Expose handles on `globalThis` if needed for teardown.
- Update `vitest.config.ts` to conditionally include `globalSetup: 'src/tests/pglite/setup-global.ts'` when `process.env.TEST_DB === 'pglite'`.
- Keep existing `src/tests/setup.ts` intact for non-PGlite runs.

6) Playwright integration
- Add `playwright.pglite.global-setup.ts` mirroring Vitest steps.
- Ensure the Next.js app under test uses the PGlite-backed Drizzle client. Options:
  - Add env-gated conditional in `src/db/index.ts` so when `TEST_DB=pglite`, it constructs the PGlite client and does not require `DATABASE_URL`.
  - Alternatively, launch the app with a distinct condition/alias that resolves an alternate `@/db` entry (advanced; optional).
- Teardown PGlite on suite end. For persistent mode, clean `.pglite/` as needed.

7) Scripts and developer UX
- Add npm scripts:
  - `test:pglite`: `TEST_DB=pglite vitest`
  - `test:pglite:watch`: `TEST_DB=pglite vitest --watch`
  - `test:e2e:pglite`: `TEST_DB=pglite playwright test`
- Document usage examples in README or here (see appendix below).

8) CI integration
- Add a job that runs `TEST_DB=pglite npm run test` and `TEST_DB=pglite npm run test:e2e`.
- Keep existing Postgres-based jobs; initially mark PGlite job `allow-failure: true` until stabilized.

9) Definition of Done
- All existing Vitest suites pass using PGlite.
- Key E2E flows pass under PGlite.
- No changes to dev/prod behavior.
- `.env.example` updated with PGlite vars; docs and scripts added.

Risks and limitations
- PGlite may not support all advanced Postgres features (extensions, some DDL). If a migration fails, document and consider a test-only conditional or simulate the outcome in seeds.
- Ensure nothing imports `@/db` (Postgres client) during module evaluation in PGlite tests, or guard it with the env conditional.

Rollback plan
- PGlite is opt-in. To roll back, stop using `TEST_DB=pglite` scripts and run current Postgres-based scripts.

Verification checklist
- `TEST_DB=pglite npm run test` → green, quick startup.
- `TEST_DB=pglite npm run test:e2e` → sanity E2E spec(s) pass.
- Compare run times and coverage to Postgres baseline.

Troubleshooting
- Error: `DATABASE_URL is not set` in tests → import `src/tests/pglite/test-db` or add the env-gated conditional in `src/db/index.ts`.
- Migration failures → log filename and SQL; skip/adjust unsupported statements for test mode only.
- Slow seeding → minimize dataset and avoid heavy loops.
- Cross-test leakage → use `PGLITE_ISOLATION=worker` or add per-test truncate helpers.

References
- PGlite docs: https://pglite.dev/docs/
- Vitest setup: https://nextjs.org/docs/app/guides/testing/vitest
- Playwright global setup/teardown: https://playwright.dev/docs/test-global-setup-teardown
- Community: drizzle + pglite guides and templates

Notes for Claude Code implementers
- Work in small, reviewable steps; keep diffs minimal and focused.
- Provide a brief plan, run logs, and verification notes in PR descriptions.
- Respect `AGENTS.md` and repo conventions; avoid mixing refactors with behavior changes.
- Prefer environment-gated switches over invasive refactors.

